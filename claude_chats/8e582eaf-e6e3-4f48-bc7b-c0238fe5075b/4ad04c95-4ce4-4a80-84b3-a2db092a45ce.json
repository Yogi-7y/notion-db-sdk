{
  "uuid": "4ad04c95-4ce4-4a80-84b3-a2db092a45ce",
  "text": " Certainly! I'll create a factory that takes in a map and returns the appropriate property based on the type. Here's an implementation of the `PropertyFactory` class:\n\n```dart\nimport '../domain/entity/property.dart';\nimport '../domain/entity/property_variants/checkbox.dart';\nimport '../domain/entity/property_variants/date.dart';\nimport '../domain/entity/property_variants/number.dart';\nimport '../domain/entity/property_variants/phone_number.dart';\nimport '../domain/entity/property_variants/status.dart';\nimport '../domain/entity/property_variants/text.dart';\nimport 'property_variants/checkbox_model.dart';\nimport 'property_variants/date_model.dart';\nimport 'property_variants/number_model.dart';\nimport 'property_variants/phone_number_model.dart';\nimport 'property_variants/status_model.dart';\nimport 'property_variants/text_model.dart';\n\nclass PropertyFactory {\n  Property call(Map<String, dynamic> map) {\n    if (map.isEmpty) {\n      throw ArgumentError('Map cannot be empty');\n    }\n\n    final propertyData = map.values.first as Map<String, dynamic>;\n    final type = propertyData['type'] as String;\n\n    switch (type) {\n      case 'rich_text':\n      case 'title':\n        return TextModel.fromMap(map);\n      case 'number':\n        return NumberModel.fromMap(map);\n      case 'checkbox':\n        return CheckboxModel.fromMap(map);\n      case 'date':\n        return DateModel.fromMap(map);\n      case 'phone_number':\n        return PhoneNumberModel.fromMap(map);\n      case 'status':\n        return StatusModel.fromMap(map);\n      default:\n        throw UnsupportedError('Unsupported property type: $type');\n    }\n  }\n}\n```\n\nThis `PropertyFactory` class has a single `call` method, which makes the class callable. It takes a `Map<String, dynamic>` as input and returns the appropriate `Property` subclass based on the type of the property.\n\nHere's how it works:\n\n1. It first checks if the input map is empty and throws an `ArgumentError` if it is.\n2. It extracts the property data from the first (and only) value in the input map.\n3. It gets the type of the property from the 'type' field in the property data.\n4. Using a switch statement, it calls the appropriate `fromMap` constructor for each property type.\n5. If an unsupported type is encountered, it throws an `UnsupportedError`.\n\nTo use this factory, you would do something like this:\n\n```dart\nfinal factory = PropertyFactory();\n\nfinal propertyMap = {\n  'Description': {\n    'id': 'abc123',\n    'type': 'rich_text',\n    'rich_text': [\n      {\n        'type': 'text',\n        'text': {\n          'content': 'This is a description',\n        },\n      },\n    ],\n  },\n};\n\ntry {\n  final property = factory(propertyMap);\n  print(property); // This will print a TextModel instance\n} catch (e) {\n  print('Error creating property: $e');\n}\n```\n\nThis factory allows you to easily create the appropriate property model from a map, which is particularly useful when parsing responses from the Notion API.\n\nRemember to create a `StatusModel` class if you haven't already, as it's referenced in this factory but wasn't present in the provided code snippets.",
  "sender": "assistant",
  "index": 3,
  "created_at": "2024-08-02T16:25:10.901346+00:00",
  "updated_at": "2024-08-02T16:25:10.901346+00:00",
  "truncated": false,
  "attachments": [],
  "files": [],
  "parent_message_uuid": "92712129-d5d5-4a97-a52c-99075fe32ed5"
}